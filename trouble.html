<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trouble - Walk</title>
<style>
  :root { --w: 100vw; --h: 100vh; --centerX: calc(var(--w)/2); --centerY: calc(var(--h)/2); }
  html,body { height:100%; margin:0; background:black; overflow:hidden; font-family: Arial, sans-serif; color:white; }
  #scene {
    position:fixed;
    inset:0;
    background-size: cover;
    background-position: center;
    transition: filter 0.45s ease, transform 0.45s ease;
  }

  /* overlay UI hotspots (invisible but capture clicks) */
  .hotspot {
    position: absolute;
    z-index: 30;
    background: transparent;
  }
  /* forward at bottom center */
  #hs-forward { width: 28%; height: 32%; left:36%; bottom:6%; }
  #hs-back { width: 28%; height: 32%; left:36%; top:6%; } /* back = top center */
  #hs-left { width: 22%; height: 40%; left:2%; top:30%; }  /* left side */
  #hs-right { width: 22%; height: 40%; right:2%; top:30%; } /* right side */

  /* small debug visible borders (comment out in production) */
  /* .hotspot { outline: 1px solid rgba(255,255,255,0.03); } */

  /* center UI: small instruction label */
  #hint {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 18px;
    z-index: 40;
    background: rgba(0,0,0,0.45);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    backdrop-filter: blur(4px);
  }

  /* monsters */
  .monster {
    position: absolute;
    width: 90px;
    height: auto;
    pointer-events: none;
    z-index: 35;
    transition: transform 0.12s linear, opacity 0.5s ease;
  }

  /* fps hand */
  #hand {
    position: absolute;
    width: 160px;
    height: auto;
    left: 50%;
    top: 60%;
    transform: translate(-50%, -50%) scale(0.8);
    z-index: 60;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.12s ease, transform 0.18s ease;
  }

  /* jumpscare overlay */
  #jumpscare {
    position: fixed;
    inset:0;
    background: black;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:200;
    opacity:0;
    pointer-events:none;
    transition: opacity 0.12s linear;
  }
  #jumpscare img { width:100%; height:100%; object-fit:cover; }

  /* small fade class for monsters disappearing */
  .fall-away {
    transition: transform 0.8s ease, opacity 0.8s ease;
    transform: translateY(40px) scale(0.9);
    opacity: 0;
  }
</style>
</head>
<body>

<div id="scene" aria-hidden="true"></div>

<!-- clickable areas -->
<div id="hs-forward" class="hotspot" data-action="forward" title="Forward"></div>
<div id="hs-back" class="hotspot" data-action="back" title="Back"></div>
<div id="hs-left" class="hotspot" data-action="left" title="Left"></div>
<div id="hs-right" class="hotspot" data-action="right" title="Right"></div>

<div id="hint">Use mouse clicks to move. Press <strong>F</strong> to punch.</div>

<img id="hand" src="fps.png" alt="hand">

<div id="jumpscare"><img src="jumpscare.png" alt="jumpscare"></div>

<audio id="punchSnd" src="punch.ogg"></audio>
<audio id="jumpsnd" src="jumpscare.ogg"></audio>

<script>
/* =========== SCENE FLOW =============
Sequence and transitions based on your description:
Entrance.png -> (forward) FirstHall.png
From FirstHall: left => Hallway1.png (with blur+movement to right)
From Hallway1: forward => HallwayEnd.png
From HallwayEnd: forward => InsideHallWayRoom.png
From InsideHallWayRoom: right => Insidehallway.png (with blur + move left)
From Insidehallway: click again => go to next page 'next.html' (change as needed)
Back (click back-hotspot) returns to previous scene (basic stack).
======================================*/

/* scene image names */
const SCENES = {
  Entrance: 'Entrance.png',
  FirstHall: 'FirstHall.png',
  Hallway1: 'Hallway1.png',
  HallwayEnd: 'HallwayEnd.png',
  InsideHallWayRoom: 'InsideHallWayRoom.png',
  Insidehallway: 'Insidehallway.png'
};

const sceneOrder = []; // we'll manage via stack for back navigation

const sceneElement = document.getElementById('scene');
const hotspots = document.querySelectorAll('.hotspot');

let currentScene = 'Entrance';

// init scene
function setScene(name, opts = {}) {
  // opts: { animateFrom: 'front'|'left'|'right'|'back' } to show blur+movement
  currentScene = name;
  sceneOrder.push(name);
  // apply background image
  sceneElement.style.backgroundImage = `url('${SCENES[name]}')`;

  if (opts.animateFrom === 'forward' || opts.animateFrom === 'left' || opts.animateFrom === 'right' || opts.animateFrom === 'back') {
    // quick blur + translate effect
    sceneElement.style.transition = 'none';
    sceneElement.style.filter = 'blur(8px)';
    sceneElement.style.transform = 'scale(1.02)';
    // small timeout to allow CSS change
    requestAnimationFrame(() => {
      setTimeout(()=> {
        sceneElement.style.transition = 'filter 0.45s ease, transform 0.45s ease';
        sceneElement.style.filter = 'blur(0px)';
        sceneElement.style.transform = 'scale(1)';
      }, 20);
    });
  } else {
    sceneElement.style.filter = 'none';
    sceneElement.style.transform = 'none';
    sceneElement.style.transition = 'filter 0.45s ease, transform 0.45s ease';
  }
}

/* start */
setScene('Entrance');

/* helper to go back one step */
function goBack() {
  if (sceneOrder.length <= 1) return;
  // pop current
  sceneOrder.pop();
  const prev = sceneOrder[sceneOrder.length - 1];
  currentScene = prev;
  sceneElement.style.backgroundImage = `url('${SCENES[prev]}')`;
}

/* action mapping based on current scene and which hotspot clicked */
function handleAction(action) {
  if (isPlayerDead) return;
  // mapping per your spec
  if (currentScene === 'Entrance') {
    if (action === 'forward') setScene('FirstHall', {animateFrom: 'forward'});
  } else if (currentScene === 'FirstHall') {
    if (action === 'left') setScene('Hallway1', {animateFrom: 'left'}); // we want blur and move to right visually
    else if (action === 'back') goBack();
    else if (action === 'forward') { /* maybe nothing or same */ }
  } else if (currentScene === 'Hallway1') {
    if (action === 'forward') setScene('HallwayEnd', {animateFrom: 'forward'});
    else if (action === 'back') goBack();
  } else if (currentScene === 'HallwayEnd') {
    if (action === 'forward') setScene('InsideHallWayRoom', {animateFrom: 'forward'});
    else if (action === 'back') goBack();
  } else if (currentScene === 'InsideHallWayRoom') {
    if (action === 'right') {
      // "click right in the HallWay room ai manda ela pra esquerda com um blur and troca para Insidehallway.png"
      setScene('Insidehallway', {animateFrom: 'right'});
    } else if (action === 'back') goBack();
  } else if (currentScene === 'Insidehallway') {
    if (action === 'forward' || action === 'right' || action === 'left') {
      // "quando clicar de novo mande para outro html"
      window.location.href = 'next.html';
    } else if (action === 'back') goBack();
  }
}

/* attach hotspot listeners */
hotspots.forEach(h => {
  h.addEventListener('click', (ev) => {
    const action = h.dataset.action;
    handleAction(action);
  });
});

/* ========== MONSTERS & PLAYER ========== */
const monsters = [];
let spawnTimer = null;
let isPlayerDead = false;
const MAX_MONSTERS = 18; // cap to avoid overload
const spawnIntervalMin = 600; // ms
const spawnIntervalMax = 1200; // ms

const centerX = window.innerWidth / 2;
const centerY = window.innerHeight * 0.6; // approximate player Y (hand is around 60%)

// helper spawn monster at random edge position
function spawnMonster() {
  if (isPlayerDead) return;
  if (monsters.length >= MAX_MONSTERS) return;
  const m = document.createElement('img');
  m.src = 'monster.png';
  m.className = 'monster';
  // spawn at random edge (top/bottom/left/right)
  const edge = Math.floor(Math.random() * 4);
  let x, y;
  const margin = 60;
  if (edge === 0) { // left
    x = -80;
    y = Math.random() * (window.innerHeight - 120) + 40;
  } else if (edge === 1) { // right
    x = window.innerWidth + 80;
    y = Math.random() * (window.innerHeight - 120) + 40;
  } else if (edge === 2) { // top
    x = Math.random() * (window.innerWidth - 120) + 40;
    y = -80;
  } else { // bottom
    x = Math.random() * (window.innerWidth - 120) + 40;
    y = window.innerHeight + 80;
  }

  m.style.left = x + 'px';
  m.style.top = y + 'px';
  m.dataset.x = x;
  m.dataset.y = y;
  m.dataset.speed = (1 + Math.random() * 1.8).toString();
  document.body.appendChild(m);

  monsters.push(m);
}

// move monsters towards player center
function updateMonsters() {
  if (isPlayerDead) return;
  for (let i = monsters.length - 1; i >= 0; i--) {
    const m = monsters[i];
    let x = parseFloat(m.dataset.x);
    let y = parseFloat(m.dataset.y);
    const speed = parseFloat(m.dataset.speed);

    const dx = centerX - x;
    const dy = centerY - y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 18) {
      // monster reached player -> death
      monsterHitPlayer();
      return;
    }
    const nx = (dx / dist) * speed;
    const ny = (dy / dist) * speed;

    x += nx;
    y += ny;

    m.dataset.x = x;
    m.dataset.y = y;
    m.style.left = x + 'px';
    m.style.top = y + 'px';

    // rotate to face movement (simple flip)
    if (nx > 0) m.style.transform = 'scaleX(1)';
    else m.style.transform = 'scaleX(-1)';
  }
  requestAnimationFrame(updateMonsters);
}

/* player punch (F key) implementation */
const handEl = document.getElementById('hand');
const punchSound = document.getElementById('punchSnd');

let punching = false;
function doPunch() {
  if (isPlayerDead) return;
  if (punching) return;
  punching = true;

  // show hand quickly
  handEl.style.opacity = '1';
  handEl.style.transform = 'translate(-50%, -65%) scale(1)';

  // find nearest monster in range
  let nearest = null;
  let nearestDist = 9999;
  monsters.forEach(m => {
    const mx = parseFloat(m.dataset.x) + (m.width ? m.width/2 : 45);
    const my = parseFloat(m.dataset.y) + (m.height ? m.height/2 : 45);
    const dx = mx - centerX;
    const dy = my - centerY;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < nearestDist) { nearestDist = d; nearest = m; }
  });

  // play sound if available
  punchSound.currentTime = 0;
  punchSound.play().catch(()=>{});

  if (nearest && nearestDist < 240) {
    // animate hand toward monster
    const origLeft = handEl.offsetLeft;
    const origTop = handEl.offsetTop;

    // compute target point
    const targetX = parseFloat(nearest.dataset.x) + 30;
    const targetY = parseFloat(nearest.dataset.y) + 30;

    // animate via CSS transform absolute move
    const clientRect = document.body.getBoundingClientRect();
    const handCenterX = centerX;
    const handCenterY = centerY;
    const tx = targetX - handCenterX;
    const ty = targetY - handCenterY;

    handEl.style.transition = 'transform 0.12s linear';
    handEl.style.transform = `translate(calc(-50% + ${tx}px), calc(-65% + ${ty}px)) scale(1.05)`;

    setTimeout(() => {
      // monster fade down and remove
      nearest.classList.add('fall-away');
      setTimeout(() => {
        try { nearest.remove(); } catch(e) {}
        const idx = monsters.indexOf(nearest);
        if (idx !== -1) monsters.splice(idx,1);
      }, 800);
      // return hand
      handEl.style.transform = 'translate(-50%, -65%) scale(0.9)';
      setTimeout(()=> {
        handEl.style.opacity = '0';
        punching = false;
      }, 200);
    }, 140);

  } else {
    // miss punch, quick hand flash
    setTimeout(() => {
      handEl.style.transform = 'translate(-50%, -65%) scale(0.9)';
      setTimeout(()=> { handEl.style.opacity = '0'; punching = false; }, 120);
    }, 160);
  }
}

/* death / jumpscare */
const jumpscareEl = document.getElementById('jumpscare');
const jumpscareSound = document.getElementById('jumpsnd');

function monsterHitPlayer() {
  if (isPlayerDead) return;
  isPlayerDead = true;
  // stop spawning
  // show jumpscare full-screen and play sound
  jumpscareEl.style.pointerEvents = 'auto';
  jumpscareEl.style.opacity = '1';
  try { jumpscareSound.currentTime = 0; jumpscareSound.play().catch(()=>{}); } catch(e){}
  // small shake/flash
  sceneElement.style.transition = 'transform 0.08s';
  sceneElement.style.transform = 'scale(1.06)';

  // after a bit, freeze or redirect
  setTimeout(() => {
    // keep jumpscare for 2s then go back to main or reload
    setTimeout(() => {
      // optional: redirect or reload
      // window.location.href = 'main.html';
    }, 2000);
  }, 80);
}

/* spawning loop */
function spawnLoop() {
  if (isPlayerDead) return;
  spawnMonster();
  const delay = Math.random() * (spawnIntervalMax - spawnIntervalMin) + spawnIntervalMin;
  spawnTimer = setTimeout(spawnLoop, delay);
}

/* start update loops */
spawnLoop();
requestAnimationFrame(updateMonsters);

/* keyboard handling */
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'f') {
    doPunch();
  }
  // for quick debug: R to reload
  if (e.key.toLowerCase() === 'r') location.reload();
});

/* ensure resize adapts center */
window.addEventListener('resize', () => {
  // update center coordinates
  // note: center used by monsters is recomputed via window inner dims each animation cycle
});

/* Small UX: clicking anywhere shows hint briefly fade */
const hint = document.getElementById('hint');
function flashHint() {
  hint.style.opacity = '1';
  hint.style.transition = 'opacity 0.3s';
  setTimeout(()=> { hint.style.opacity = '0.28'; }, 1800);
}
setTimeout(()=> { hint.style.opacity = '0.9'; }, 200);
</script>
</body>
</html>
