<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>DISTURBED ENGINE</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; cursor: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* Efeito de Grão/Estática */
        #noise-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://media.giphy.com/media/oEI9uWUicLpsc/giphy.gif');
            opacity: 0.08; pointer-events: none; z-index: 50; mix-blend-mode: overlay;
        }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 10%, rgba(0,0,0,0.98) 45%, black 100%);
            pointer-events: none; z-index: 10;
        }

        #minimap {
            position: absolute; top: 15px; left: 15px; width: 120px; height: 120px;
            border: 1px solid #200; background: rgba(0, 0, 0, 0.9); z-index: 30; opacity: 0.6;
        }

        #jumpscare-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; align-items: center; justify-content: center;
        }
        #jumpscare-img { width: 110%; height: 110%; object-fit: cover; filter: contrast(1.5) grayscale(0.5); }
    </style>
</head>
<body>

    <div id="noise-overlay"></div>
    <canvas id="minimap"></canvas>
    <div id="vignette"></div>
    <canvas id="game"></canvas>
    
    <div id="jumpscare-overlay">
        <img id="jumpscare-img" src="Jumpscare.png" />
    </div>

<script>
    const enemyImg = new Image();
    enemyImg.src = "Jumpscare.png";

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const mCanvas = document.getElementById('minimap');
    const mCtx = mCanvas.getContext('2d');
    const vignette = document.getElementById('vignette');
    
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;
    mCanvas.width = 120; mCanvas.height = 120;

    // --- AUDIO PERTURBADOR ---
    let audioCtx, noiseNode, noiseGain;
    function initDisturbedAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const bufferSize = 2 * audioCtx.sampleRate,
            noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate),
            output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
            
            noiseNode = audioCtx.createBufferSource();
            noiseNode.buffer = noiseBuffer;
            noiseNode.loop = true;
            noiseGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            noiseNode.connect(filter);
            filter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseNode.start();
        }
    }

    // Mapa
    const mapSize = 16;
    const worldMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1],
        [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],
        [1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1],
        [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
        [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let posX = 1.5, posY = 1.5, dirX = 1, dirY = 0, planeX = 0, planeY = 0.66, pitch = 0;
    let enemyX = 14, enemyY = 11, isGameOver = false, running = false;
    let zBuffer = new Array(w);

    document.addEventListener('click', () => {
        canvas.requestPointerLock();
        initDisturbedAudio();
    });

    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === canvas && !isGameOver) {
            let rot = e.movementX * 0.003;
            let oldDirX = dirX;
            dirX = dirX * Math.cos(rot) - dirY * Math.sin(rot);
            dirY = oldDirX * Math.sin(rot) + dirY * Math.cos(rot);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(rot) - planeY * Math.sin(rot);
            planeY = oldPlaneX * Math.sin(rot) + planeY * Math.cos(rot);
            pitch = Math.max(-400, Math.min(400, pitch - e.movementY * 1.2));
        }
    });

    const keys = {};
    window.onkeydown = (e) => { keys[e.code] = true; if(e.shiftKey) running = true; };
    window.onkeyup = (e) => { keys[e.code] = false; if(!e.shiftKey) running = false; };

    function update() {
        if (isGameOver) return;
        let speed = running ? 0.08 : 0.045;
        if (keys['KeyW']) {
            if (worldMap[Math.floor(posY)][Math.floor(posX + dirX * speed)] === 0) posX += dirX * speed;
            if (worldMap[Math.floor(posY + dirY * speed)][Math.floor(posX)] === 0) posY += dirY * speed;
        }
        if (keys['KeyS']) {
            if (worldMap[Math.floor(posY)][Math.floor(posX - dirX * speed)] === 0) posX -= dirX * speed;
            if (worldMap[Math.floor(posY - dirY * speed)][Math.floor(posX)] === 0) posY -= dirY * speed;
        }
        if (keys['KeyA']) {
            if (worldMap[Math.floor(posY)][Math.floor(posX - planeX * speed)] === 0) posX -= planeX * speed;
            if (worldMap[Math.floor(posY - planeY * speed)][Math.floor(posX)] === 0) posY -= planeY * speed;
        }
        if (keys['KeyD']) {
            if (worldMap[Math.floor(posY)][Math.floor(posX + planeX * speed)] === 0) posX += planeX * speed;
            if (worldMap[Math.floor(posY + planeY * speed)][Math.floor(posX)] === 0) posY += planeY * speed;
        }

        // --- IA ACELERADA ---
        let dx = posX - enemyX, dy = posY - enemyY, dist = Math.sqrt(dx*dx + dy*dy);
        
        // Se aproxima mais rápido quanto mais perto está (Aceleração Exponencial)
        let currentEnemySpeed = 0.02 + (0.06 / (dist + 0.5)); 
        enemyX += (dx/dist) * currentEnemySpeed;
        enemyY += (dy/dist) * currentEnemySpeed;

        // Som aumenta com a proximidade
        if(noiseGain) noiseGain.gain.value = Math.min(0.4, 0.05 + (0.3 / dist));

        if(dist < 0.35) {
            isGameOver = true;
            document.getElementById('jumpscare-overlay').style.display = 'flex';
            if(audioCtx) { // Grito de estática pura
                let osc = audioCtx.createOscillator();
                let g = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.value = 100;
                g.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.1);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start();
            }
        }
    }

    function render() {
        // Flicker da Lanterna
        let flicker = Math.random() > 0.96 ? 0.5 : 1;
        vignette.style.opacity = 0.8 + (Math.random() * 0.2);

        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);

        for (let x = 0; x < w; x++) {
            let camX = 2 * x / w - 1, rDX = dirX + planeX * camX, rDY = dirY + planeY * camX;
            let mX = Math.floor(posX), mY = Math.floor(posY);
            let dDX = Math.abs(1/rDX), dDY = Math.abs(1/rDY), sX, sY, sDX, sDY;
            if (rDX < 0) { sX = -1; sDX = (posX - mX) * dDX; } else { sX = 1; sDX = (mX + 1 - posX) * dDX; }
            if (rDY < 0) { sY = -1; sDY = (posY - mY) * dDY; } else { sY = 1; sDY = (mY + 1 - posY) * dDY; }
            let hit = 0, side;
            while (hit === 0) {
                if (sDX < sDY) { sDX += dDX; mX += sX; side = 0; } else { sDY += dDY; mY += sY; side = 1; }
                if (worldMap[mY][mX] > 0) hit = 1;
            }
            let distP = (side === 0) ? (sDX - dDX) : (sDY - dDY);
            zBuffer[x] = distP;
            let lH = Math.floor(h / distP);
            let start = -lH / 2 + h / 2 + pitch, end = lH / 2 + h / 2 + pitch;
            let lum = (side === 1 ? 0.6 : 1) * (5 / (distP + 1)) * flicker;
            ctx.fillStyle = `rgb(${20*lum},${15*lum},${15*lum})`; // Paredes quase pretas, avermelhadas
            ctx.fillRect(x, start, 1, end - start);
        }

        // Render Sprite
        let sX = enemyX - posX, sY = enemyY - posY, invD = 1/(planeX*dirY - dirX*planeY);
        let tX = invD * (dirY * sX - dirX * sY), tY = invD * (-planeY * sX + planeX * sY);
        if (tY > 0.1) {
            let scX = Math.floor((w/2)*(1+tX/tY)), sH = Math.abs(Math.floor(h/tY)), sW = Math.abs(Math.floor(h/tY));
            let dSX = Math.floor(-sW/2 + scX), dEX = Math.floor(sW/2 + scX);
            for (let i = dSX; i < dEX; i++) {
                if (i > 0 && i < w && tY < zBuffer[i]) {
                    ctx.globalAlpha = Math.min(1, 2/tY); // Bixo some na escuridão
                    ctx.drawImage(enemyImg, (i-dSX)*(enemyImg.width/sW), 0, 1, enemyImg.height, i, -sH/2+h/2+pitch, 1, sH);
                    ctx.globalAlpha = 1;
                }
            }
        }
        // Minimap
        mCtx.fillStyle = "#000"; mCtx.fillRect(0,0,120,120);
        let b = 120/mapSize;
        mCtx.fillStyle = "#100";
        for(let i=0; i<worldMap.length; i++) for(let j=0; j<mapSize; j++) if(worldMap[i][j]) mCtx.fillRect(j*b, i*b, b, b);
        mCtx.fillStyle = "#0f0"; mCtx.fillRect(posX*b-1, posY*b-1, 2, 2);
        mCtx.fillStyle = "#f00"; mCtx.fillRect(enemyX*b-1, enemyY*b-1, 2, 2);
    }

    function loop() { update(); render(); requestAnimationFrame(loop); }
    loop();
</script>
</body>
</html>
